<!DOCTYPE html>
<html lang="en">
	<head>
    
		<title>astor-sees</title>
		<meta charset="utf-8">
    
		<style>
			body {
				margin: 0px;
				background-color: black;
				overflow: hidden;
			}
		</style>
    
	</head>
	<body>
    
		<button id="photo">Take Photo</button>
		<video id="video" width="200" height="200" autoplay></video>
		<canvas id="canvas" width="1024" height="1024"></canvas>

		<script>

      // Prefer camera resolution nearest to 1280x720.
      var constraints = { 
        audio: true, 
        video: { 
          facingMode: 'environment',
          width: {max : 1280}, 
          height: {max : 720} 
        } 
//        video: { 
//          width: {max : 16}, 
//          height: {max : 16} 
//        } 
      }; 


      
      var video = document.getElementById("video");
      var canvas = document.getElementById("canvas");
      var context = canvas.getContext("2d");
//      attachCameraToVideo(video);

      // On button click, copy a video frame to the canvas and initialize the WebGL animation
      document.getElementById("photo").addEventListener("click", function() {
        // copy the contents of the video into the photo canvas
        // change last 2 params of below to scale the video frame image
        context.drawImage(video, 0, 0, 200,200);
        
        const myPng = canvas.toDataURL();
        console.log(myPng);
        alert(myPng.substr(0, 30));
  //			createWebGLAnimation();
      });
      
      navigator.mediaDevices.getUserMedia(constraints)
      .then(function(mediaStream) {
        video = document.querySelector('video');
//        var video = document.querySelector('video');
        video.srcObject = mediaStream;
        video.onloadedmetadata = function(e) {
          video.play();
        };
      })
      .catch(function(err) { console.log(err.name + ": " + err.message); }); // always check for errors at the end.
      
      
//		// Set up Three.js scene variables, and HTML video capture variables
////		var mesh, camera, scene, renderer;
//		var video = document.getElementById("video");
//		var canvas = document.getElementById("canvas");
//		var context = canvas.getContext("2d");
//		attachCameraToVideo(video);
//
//		// On button click, copy a video frame to the canvas and initialize the WebGL animation
//		document.getElementById("photo").addEventListener("click", function() {
//			// copy the contents of the video into the photo canvas
//			// change last 2 params of below to scale the video frame image
//			context.drawImage(video, 0, 0, 1024,1024);
////			createWebGLAnimation();
//		});
//
//		function attachCameraToVideo(video) {
//			// set up parameters
//			var videoParams = { "video": true };
//			var errorCallback = function(error) {
//				console.log("Video capture error: ", error.code); 
//			};
//      
//			// connect to camera
//			if(navigator.getUserMedia) {
//				navigator.getUserMedia(videoParams, function(stream) {
//					video.src = stream;
//					video.play();
//				}, errorCallback);
//			}
////			else if(navigator.webkitGetUserMedia) {
////				navigator.webkitGetUserMedia(videoParams, function(stream){
////					video.src = window.webkitURL.createObjectURL(stream);
////					video.play();
////				}, errorCallback);
////			}
////			else if(navigator.mozGetUserMedia) {
////				navigator.mozGetUserMedia(videoObj, function(stream){
////					video.src = window.URL.createObjectURL(stream);
////					video.play();
////				}, errorCallback);
////			}
//		}
//
//
//
////		function initWebGL() {
////			// create camera
////			camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 100 );
////			camera.position.z = 50;
////			scene = new THREE.Scene();
////
////			var texture = new THREE.Texture(canvas);
////			texture.needsUpdate = true;
////
////			// create the cube
////			var geometry = new THREE.BoxGeometry( 33,33,33 );
////			var material = new THREE.MeshBasicMaterial( { map: texture } );
////			mesh = new THREE.Mesh(geometry, material);
////			mesh.position.x = 0;
////			mesh.position.y = 0;
////			scene.add(mesh);
////
////			// create the output canvas
////			renderer = new THREE.WebGLRenderer( { antialias: true } );
////			renderer.setPixelRatio( window.devicePixelRatio );
////			renderer.setSize( window.innerWidth, window.innerHeight );
////			document.body.appendChild( renderer.domElement );
////			window.addEventListener( 'resize', onWindowResize, false );
////		}
//
//		function onWindowResize() {
//			// only runs when the window gets resized
//			camera.aspect = window.innerWidth / window.innerHeight;
//			camera.updateProjectionMatrix();
//			renderer.setSize( window.innerWidth, window.innerHeight );
//		}
//
////		function animate() {
////			// call this function at the same speed as the screen's refresh rate
////			requestAnimationFrame( animate );
////			// rotate cube a bit
////			var time = Date.now() * 0.001;
////			mesh.rotation.x = time*50;
////			mesh.rotation.y = time*50;
////			// redraw the output canvas
////			renderer.render( scene, camera );
////		}
//      
//      
      
		</script>
	</body>
</html>


