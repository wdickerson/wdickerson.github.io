<!DOCTYPE html>
<html lang="en">
	<head>
    
		<title>astor-sees</title>
		<meta charset="utf-8">
    
		<style>
			body {
				margin: 0px;
				background-color: black;
				overflow: hidden;
			}
		</style>
    
	</head>
	<body>
    
		<button id="photo">Take Photo</button>
		<video id="video" width="100" height="100" autoplay></video>
		<canvas id="canvas" width="1024" height="1024"></canvas>

		<script>

		// Set up Three.js scene variables, and HTML video capture variables
//		var mesh, camera, scene, renderer;
		var video = document.getElementById("video");
		var canvas = document.getElementById("canvas");
		var context = canvas.getContext("2d");
		attachCameraToVideo(video);

		// On button click, copy a video frame to the canvas and initialize the WebGL animation
		document.getElementById("photo").addEventListener("click", function() {
			// copy the contents of the video into the photo canvas
			// change last 2 params of below to scale the video frame image
			context.drawImage(video, 0, 0, 1024,1024);
//			createWebGLAnimation();
		});

		function attachCameraToVideo(video) {
			// set up parameters
			var videoParams = { "video": true };
			var errorCallback = function(error) {
				console.log("Video capture error: ", error.code); 
			};
      
			// connect to camera
			if(navigator.getUserMedia) {
				navigator.getUserMedia(videoParams, function(stream) {
					video.src = stream;
					video.play();
				}, errorCallback);
			}
			else if(navigator.webkitGetUserMedia) {
				navigator.webkitGetUserMedia(videoParams, function(stream){
					video.src = window.webkitURL.createObjectURL(stream);
					video.play();
				}, errorCallback);
			}
			else if(navigator.mozGetUserMedia) {
				navigator.mozGetUserMedia(videoObj, function(stream){
					video.src = window.URL.createObjectURL(stream);
					video.play();
				}, errorCallback);
			}
		}



//		function initWebGL() {
//			// create camera
//			camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 100 );
//			camera.position.z = 50;
//			scene = new THREE.Scene();
//
//			var texture = new THREE.Texture(canvas);
//			texture.needsUpdate = true;
//
//			// create the cube
//			var geometry = new THREE.BoxGeometry( 33,33,33 );
//			var material = new THREE.MeshBasicMaterial( { map: texture } );
//			mesh = new THREE.Mesh(geometry, material);
//			mesh.position.x = 0;
//			mesh.position.y = 0;
//			scene.add(mesh);
//
//			// create the output canvas
//			renderer = new THREE.WebGLRenderer( { antialias: true } );
//			renderer.setPixelRatio( window.devicePixelRatio );
//			renderer.setSize( window.innerWidth, window.innerHeight );
//			document.body.appendChild( renderer.domElement );
//			window.addEventListener( 'resize', onWindowResize, false );
//		}

		function onWindowResize() {
			// only runs when the window gets resized
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}

//		function animate() {
//			// call this function at the same speed as the screen's refresh rate
//			requestAnimationFrame( animate );
//			// rotate cube a bit
//			var time = Date.now() * 0.001;
//			mesh.rotation.x = time*50;
//			mesh.rotation.y = time*50;
//			// redraw the output canvas
//			renderer.render( scene, camera );
//		}
		</script>
	</body>
</html>


